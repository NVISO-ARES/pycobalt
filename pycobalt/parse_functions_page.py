#!/usr/bin/env python3

"""
Generate aggressor.py based on the aggressor documentation functions.html page.
"""

from bs4 import BeautifulSoup
import requests
import textwrap
import re

urls = ('https://www.cobaltstrike.com/aggressor-script/functions.html', 'https://www.cobaltstrike.com/aggressor-script/rfunctions.html')
out = 'aggressor.py'

# Additional sleep/aggressor functions to include
sleep_functions = [
    # print-related
    'print',
    'println',
    'printAll',
    'warn',
    'debug',

    # aggressor
    'command',

    # other
    'cast',
    'casti',
    'typeOf',
    'exit',
    'systemProperties',
    'cwd',
]

# Functions that support the ! operator. May be incomplete.
silent_functions = [
    'bdllspawn',
    'bdownload',
    'bexecute',
    'bhashdump',
    'blogonpasswords',
    'bmkdir',
    'bnet',
    'bpowerpick',
    'bpowershell',
    'bpowershell_import',
    'bpwd',
    'brm',
    'bscreenshot',
    'bshell',
    'bsleep',
    'btimestomp',
    'bupload_raw',
    'bjobs',
    'bcp',
    'bkill',
    'bkeylogger',
    'bexecute_assembly',
]

function_arguments = {
    'is64': ('bid',),
    'isadmin': ('bid',),
    'isbeacon': ('bid',),
    'isssh': ('bid',),
    'action': ('message',),
    'add_to_clipboard': ('text',),
    'applications': (),
    'archives': (),
    'artifact': ('listener', 'format', 'remote', 'architecture'),
    'artifact_sign': ('contents',),
    'artifact_stageless': ('listener', 'format', 'architecture', 'proxy', 'callback'),
    'blog': ('bid', 'message'),
    'blog2': ('bid', 'message'),
    'btask': ('bid', 'message'),
    'berror': ('bid', 'message'),
    'bcd': ('bid', 'folder'),
    'bclear': ('bid',),
    'bdata': ('bid',),
    'beacon_data': ('bid',),
    'beacon_info': ('bid', 'key'),
    'bdownload': ('bid', 'file'),
    'bexit': ('bid',),
}

def main():
    print('downloading list')

    functions = {}
    for url in urls:
        html = requests.get(url).text
        soup = BeautifulSoup(html, 'html5lib')

        print('parsing')

        # <h2><a href="#-is64">-is64</a></h2>
        container = soup.find('div', {'class': 'col-lg-12'})

        # get names
        names = []
        for h2 in container.find_all('h2'):
            for a in h2.find_all('a'):
                name = a.text.strip()
                names.append(name)

        # get docs
        docs = []
        for div in container.find_all('div'):
            doc = div.text
            docs.append(doc)

        # fix up docs
        for name, doc in zip(names, docs):
            doc = doc.encode('utf-8', 'ignore').decode('utf-8', 'ignore')
            doc = doc.replace('\t', ' ' * 4)
            doc = '\n'.join([line.rstrip() for line in doc.splitlines()])
            doc = '\nDocumentation from {}:\n'.format(url) + textwrap.indent(doc, ' ' * 4)
            functions[name] = doc

    # add sleep functions
    for func in sleep_functions:
        functions[func] = '\nSleep function. See http://sleep.dashnine.org/manual/index.html'

    # indent docs
    for name, doc in functions.items():
        doc = textwrap.indent(doc, ' ' * 4)
        functions[name] = doc

    print('found {} functions'.format(len(functions)))

    # now start to put together aggressor.py
    data = ''

    # file header
    data += '''\
"""
For calling aggressor functions

This file is auto-generated by ./parse_functions_page.py
"""

import pycobalt.engine as engine

'''

    for func, doc in functions.items():
        #max_arg = 0

        # find max arg
        #if '# Arguments' in doc:
        #    for match in re.finditer('\$([0-9]+)', doc):
        #        num = int(match.group(1))
        #        max_arg = max(num, max_arg)
        if not doc:
            doc = ''

        pyname = func.replace('-', '')
        if func in silent_functions:
            data += '''
def {pyname}(*args, silent=False, fork=None, sync=True):
    r""""{doc}
    """

    return engine.call('{name}', args, silent=silent, fork=fork, sync=sync)

'''.format(name=func, pyname=pyname, doc=doc)
        else:
            data += '''
def {pyname}(*args, fork=None, sync=True):
    r"""{doc}
    """

    return engine.call('{name}', args, fork=fork, sync=sync)

'''.format(name=func, pyname=pyname, doc=doc)

    print('writing to {}'.format(out))
    with open(out, 'w+') as out_fp:
        out_fp.write(data)

if __name__ == '__main__':
    main()
